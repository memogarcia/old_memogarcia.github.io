---
layout: post
title:  "Pratai, Event driven compute for OpenStack"
date:   2016-07-12 12:30:00
categories: pratai openstack serverless events compute
---

**Note** This is a Work-In-Progress Document, source code will be added later.

### Abstract

Pratai provides an incredible flexibility on how to migrate workloads to the
cloud that respond to events without having to manage any server or network,
this allows your systems to be more flexible, loosely-coupled, scalable and
easier to develop while offering a more tolerant to failure environments.

Pratai offers an event driven platform that works with OpenStack to provide
server-less applications and services, No infrastructure management,
no VM spawning, no network provisioning, just run your code in OpenStack.


### How it works

The goal of Pratai is simple. Deploy "code" (disclaimer, from now on I
will refer to code as functions), that will react to an event without
worrying about anything else, the platform handles the execution. Simple right?

In order to achieve that, first, we need to deploy a function in a `zip` format for one of the
languages that the platform supports, the first one is python but more will be
added in the future, after this a docker image gets created with the custom
function and the requirements. e.g.

{% highlight python %}

# new_module.py

import numpy # yes you can install dependencies, just send a requirements.txt

def local_function(payload):
    # you can create local functions
    return payload

def main(payload=None):
    # a main function should always be declared
    # and using a payload as a parameter
    return local_function(payload)

{% endhighlight %}

When a function gets created it will remain as inactive, waiting to be executed
whenever an event happens that the function is subscribed to, could be a http
endpoint, which can be assigned at creation time, or a message in a queue but
basically every event will spawn a container that will execute the event and
then disappear.


### Architecture

#### Control Plane

An API gateway, a database cluster and a load balancer, and agent and a scheduler
runs in the control plane.

For the first version a API gateway built in python using flask will be made,
in the future I think Golang should be a better option for it.

An elasticsearch cluster will power the storage of events, function metadata
and cluster information.

And a nginx load balancer will connect 3 instances to the API in a `least_connect`
manner.

#### Pratai Nodes

A Pratai node is composed by a driver and runtimes.

When a new node is created it will automatically connect to the cluster and it
will start polling for events.

A driver is basically a container orchestrator like swarm, kubernetes, plain
docker, etc. in this case we will use docker.

The runtimes are the languages supported by the platform, they are a base
container image that contains an OS, a language and its dependencies, etc. that
can be used by the functions the users submits. e.g.

{% highlight bash %}

# seed/Dockerfile

FROM ubuntu:14.04

MAINTAINER Memo Garcia <sirmemogarcia@gmail.com>

RUN apt-get -y update

RUN apt-get install -y git unzip wget

{% endhighlight %}


{% highlight bash %}

# python27/Dockerfile

FROM pratai/seed:latest

MAINTAINER Memo Garcia <sirmemogarcia@gmail.com>

RUN apt-get install -y python python-dev python-setuptools python-pip
RUN pip install pip --upgrade

{% endhighlight %}

{% highlight bash %}

# python27_template.txt

FROM pratai/python27:latest
MAINTAINER Memo Garcia <sirmemogarcia@gmail.com>
RUN wget {zip_location}
RUN unzip {zip_file}
RUN pip install -r requirements.txt
RUN mkdir /etc/pratai/
RUN mkdir /var/log/pratai/
RUN cp new_module.py /etc/pratai/
RUN git clone "repo_with_runtimes"
CMD ["python", "/pratai-runtimes/runtimes/python27/server.py"]

{% endhighlight %}

#### Distributed Queues

ZeroMQ is the choice for queuing and passing messages in pratai using the PUSH/PULL
architecture we can create a pipelines of messages that can be distributed
across multiple nodes.

We will have a producer and a collector running in the scheduler, and consumers
running in the pratai nodes, one consumer should be spawned per thread.

![Reference architecture](/images/pushpull.png)

### Events

A function can react to any event coming through http/https request or messages
in a queue, even events that happen in a database can trigger a function, is
important to notice that a response of a function is an event, so it can trigger
so chaining functions to build pipelines of data processing is easy with Pratai.

There are 2 kinds of events, `async` and `wait_for_response`

#### Async

When an async event gets triggered it won't block the request until the function
finish the process, instead it will acknowledge the event and response with  a
`202 status code` and a `request_id`, you can retrieve the status by getting
the logs or query the api with the request_id

#### Wait For Response

**This wont be included in the first release**
In the other hand a wait_for_response event will block the request until the
function finish to process the data. this is great tool to create API's


### Components

#### REST API

{% highlight bash %}

{url}/api
{url}/api/functions
{url}/api/functions/{function_id}
{url}/api/runtimes
{url}/api/runtimes/{runtime_id}
{url}/api/events
{url}/api/events/{event_id}
{url}/api/status

{% endhighlight %}

This are the available endpoints for Pratai, they will be discussed with more
details in the official documentation, but basically they support CRUD operations
for all the available endpoints

#### Agent

WIP

#### client

python-prataiclient is the component that allows the user to interact with the
api from the command line interface, with it you can do stuff like this:

{% highlight bash %}

pratai function-create music_tag --file /path/to/zip --description \
    "extract metadata from music files" --memory 128

pratai function-list

{% endhighlight %}

Because this is OpenStack you should pass credentials to interact with the
platform

{% highlight bash %}

export OS_USERNAME=user
export OS_PASSWORD=password
export OS_TENANT_NAME=pratai_tenant
export OS_PRATAI_URL=http://192.168.33.9:9096
export OS_IDENTITY_API_VERSION=3
export OS_AUTH_URL=http://192.168.33.9:5000/v3
export OS_PROJECT_NAME=pratai_tenant
export OS_PROJECT_DOMAIN_NAME=Default
export OS_USER_DOMAIN_NAME=Default

{% endhighlight %}

#### Drivers

WIP

#### Runtimes

WIP

#### Scheduler

WIP

### Security & Secrets

The functions that interact with external services most often that not they
require to use credentials to connect, for this, Barbican has been proposed to
help with this scenario.

We definitely recommend using tokens instead of user/passwords when possible.  

### Community

Join us at `#pratai` irc channel in `freenode`

### References

[The Reactive Manifesto](http://www.reactivemanifesto.org)

[Cloud Design Patterns](https://msdn.microsoft.com/en-us/library/dn600223.aspx)
